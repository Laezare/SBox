------
SYMFONY :

ETAPE 1 : Installation de SF 4
ETAPE 2 : Routes et les controllers
ETAPE 3 : Entity et DOCTRINE ORM (mapping)
ETAPE 4 : Twig et les assets
ETAPE 5 : Doctrine DBAL
ETAPE 6 : Les formulaires
ETAPE 7 : Sécurité et utilisateurs
ETAPE 8 : Association Mapping
----------------

ETAPE 1 : Installation de SF 4

1/ Composer

    - Composer est un gestionnaire de dépendances (services, les composants)

    URL : www.getcomposer.org


2/ Installation d'un nouveau projet

    <cmd>
    composer create-project symfony/website-skeleton Blog

3/ Lancement de l'application

    <cmd>
    cd Blog
    php bin/console server:run

    ===> localhost:8000 (page de welcome)

4/ architecture des dossiers et fichiers

    - bin/ : executables de SF
    - Config/ : Le dossier de configuration de notre app
    - Public/ : Le repertoire web (index.php, css, js, fonts, img)
    - src/ : code propriétaire de notre app (MC)
    - templates/ : code HTML de  notre app (V)
    - tests/ : Tests unitaires
    - translations/ : Fichiers de traductions
    - vendor/ : Code source de SF
    - var/ : les éléments qui sont écrits au fur et à mesure du script
    - composer.json : Permet à composer de mettr eà jour l'app
    - .env : variables d'environnement


ETAPE 2 : Routes et les controllers

- Les routes ce sont les URL, les fonctionnalités, les pages...

1/ Création d'un controller
<cmd>
php bin/console make:controller

2/ Les différentes routes
    - @Route("/bonjour")  == route avec affichage + erreur
    - @Route("/hello") == route avec affichage sans erreur (objet Response)
    - @Route("/hola/{prenom}") == route avec response + donnée dynamique
    - @Route("/ciao/{prenom}") == route avec vue + donnée dynamique
    - @Route("/redirect") == route avec redirection
    - @Route("/message") == route avec message flash


3/ L'objet Response
    <code>
    use Symfony\Component\HttpFoundation\Response;

    - Le protocol HTTP requiert une requete et une reponse. L'objet Response en est la réponse.

    - L'objet response peut gérer (par exemple) l'affichage de l'entête de la page

4/ L'objet Request
    <code>
    use Symfony\Component\HttpFoundation\Response;

    - L'objet request représente la partie Requete du protocle HTTP.

    - Il permet de gérer : session, post, get, cookies, server...

5/ La redirection

    - La redirection est utile lorsqu'un utilisateur a effectué une action qui requiert que la page (ou une autre page) soit chargée

    - Pour cibler la page vers laquelle on redirige, on cible le name de la route (comme pour les liens)

    ===> A partir de maintenant toutes nos routes doivent avoir un lien.

6/ Les messages flash

    - Les message en session (flash) sont utiles pour afficher des informations à l'utilisateur (client ou admin). Tout est automatisé avec SF et le controller.

------------------------------------------
ETAPE 3 : Entity et DOCTRINE ORM (mapping)

1/ Concept des Entity

    - Avec doctrine, nous n'allons plus faire de SQL, et nous n'allons plus mettre les mains dans phpmyadmin.
    - Nous allons manipuler des objets.

2/ Doctrine ORM (mapping)

    - DOCTRINE ORM : Object Relationnal Mapping
    - Pour que Doctrine puisse fonctionner, il va falloir lui explique que nos objets correspondent à une BDD ---> Mapping



3/ Générer nos entités en ligne de commande

    <cmd>
    php bin/console make:entity

    _ On suit les étapes, et cela nous génère un fichier User.php dans src/Entity. Le mmaping ORM est généré


4/ Créer la BDD

    Dans le fichier .env, à la ligne DATABASE, on renseigner les infos de connexion (login, mdp, server, port, dbname)

    <cmd>
    php bin/console doctrine:database:create
    php bin/console make:migration
    php bin/console doctrine:migration:migrate

    ===> La base de données est créée :) !!

5/ Générer les entités via la BDD

    - On peut fonctionner dans l'autre sens et générer nos entités sur la base d'une BDD qui existerait déjà.

    <cmd>
    php bin/console doctrine:mapping:import "App\Entity" annotation --path=src/Entity

    php bin/console make:entity --regenerate

6/ Créer du faux contenu avec les fixtures

    - Les fixtures nous permettent de créer "facilement" du faux contenu, et aussi de le remettre dans son état initial, à tout moment.

    <cmd>
    composer require --dev orm-fixtures

    src/DataFixtures/Appfixtures.php : On créé des boucles pour créer des objets (user, post, comment).

    <cmd>
    php bin/console doctrine:fixtures:loaded

    INFO : Il existe un composant FAKER, qui permet de générer de la data réaliste (tel, email, title, nom/prenom)


    ===> A ce stade nous avons des données dans la bdd

----------------------------
ETAPE 4 : Twig et les assets

 - Twig est un moteur de template. L'objectif c'est de nous permettre de mettre du PHP dans les vues de manière plus simple. Il existe d'autres moteurs de templates (blade, tpl, smarty...). Twig a été créé par sensiolabs, mais on peut l'utiliser dans tous nos projets.

1/ Affichage des variables

    <p>Bonjour <?= ucfirst($prenom) ?> !</p>
    echo '<p>Bonjour ' . $prenom . ' !</p>'

    <p>Bonjour {{ prenom  | capitalize }}</p>

    --

    Bonjour <?= $user['prenom'] ?>
    Bonjour <?= $user -> getPrenom() ?>
    Bonjour {{ user.prenom }}

    --

    {% set maVariable = 'toto' %}

2/ Les boucles

    <?php  foreach( $posts as $value ) : ?>
    <?php  endforeach ?>

    {% for value in posts %}
    {% endfor %}

    -----

    <?php for($i = 1; $i <= 10; $i ++) : ?>
    <?php endfor ?>

    {% for i in 1..10 %}
    {% endfor %}

    -----


3/ Les conditions
4/ L'héritage

    - Twig embarque un système d'héritage. Dans la vue on ne require pas le haut et le bas du site, mais on hérite (extends) d'un layout (base.html.twig) qui contient le haut et le bas du site.

    - Dans ce système d'héritage, on crée des block qui peuvent accueillir ou non du contenu (content, slideshow, aside, js, css)

    ---> Cela nous offrir une flexibilité parfaite pour la création de nos vues.
    ---> On peut avoir (par exemple) un layout pour le front et un layout pour le back (admin)

5/ Les assets

    - La fonction asset nous permet de faire un lien ABSOLU vers une ressources (img, css, js, fonts etc..)

    href="../../../../public/css/styles.css"
    href="{{ asset('/css/styles.css') }}"

    src="../../../public/photo/<?= $post['photo'] ?>"
    src="{{ asset('/photo/' ~ p.photo ) }}"

6/ Les liens

    - La fonction path() nous permet de définir un lien absolu vers une route (page). On cible une route, et non une url.

    href="register.php"
    href="{{ path('register') }}"

    liens dynamiques :

    href="post.php?id=<?= $post['id'] ?>"
    href="{{ path('post', { id : p.id } ) }}"
        -> post    --> nom de la route
        -> id      --> paramètre dynamique
        -> p.id    --> valeur du paramètre dynamique


7/ La doc

    Lien : https://twig.symfony.com/doc/2.x/filters/capitalize.html


ETAPE 5 : Doctrine DBAL

1/ Qu'est-ce Doctrine DBAL

    - DBAL : DATABASE ABTRACT LAYER -> Sur-couche à PDO

2/ Comment accéder au services Doctrine DBAL

    $repository = $this -> getDoctrine() -> getRepository(Post::class);

    $manager = $this -> getDoctrine() -> getManager();




3/ SELECT * FROM ... (findAll())

    - La fonction findAll() du repository nous permet de récupérer toutes les entrées d'une table.

4/ SELECT * FROM ... WHERE id = ...  (find($id))

    - La fonction find($id) permet de récupérer une entrée par son ID

    /!\ Utilisée depuis le manager elle prend en 1er argument l'entité find(Post::class, $id)

5/ SELECT * FROM ... WHERE ...  = ...

    findBy() permet de récupérer des entrées en fonction d'un champs donné, et d'une valeur.

    findOneBy() permet de récupérer une seule entrée en fonction d'un champs donné, et d'une valeur.

    findBy(
        [
            'category' => 'tshirt',
            'color' => 'red',
            'size' => 'L'
        ],
        [
            'price' => 'ASC'
        ],
        10, 0
    );

    findBy() est une fonction complète qui nous permet de faire les filtre et tri de manière exhaustive.
    Je vous renvoie à la doc pour aller plus avec cette fonction.






6/ INSERT / UPDATE

    <code>
    $post = new Post;
    $post -> setXXX();
    $manager -> persist($post);
    $manager -> flush();

    Pour ajouter un post, on crée un objet vide. On le persist grâce au manager afin de le "rentrer dans le systeme". La fonction flush du manager permet d'enregistrer en BDD.
    Ce sont les informations du formulaire qui viendront (plus tard) alimenter l'objet vide.

    La modification d'une entrée se passe de la même manière à ceci près que l'objet persisté n'est pas vide mais remplie. Il viendra alimenter les champs du formulaire (plus tard), on parle d'hydrater le formulaire.

7/ DELETE
    <code>
    $post = $manager -> find(Post::class, $id)
    $manager -> remove($post);
    $manager -> flush();

    Pour supprimer une entrée il faut d'abord la récupérer. Puis la fonction remove() du manager permet de le supprimer de la BDD, confirmé par le flush();



8/ Requete perso Query Builder (PHP) et/ou Create Query (DQL)

    - Doctrine nous fournit des outils pour créer des requête en PHP (findAll, find, findBy, persist, remove, flush...)

    - Néanmoins, il se peut que notre app nécessite des requêtes plus spécifiques :

     - Query builder  : construction d'une requête grâce PHP

     - create query : l'éxécution d'une requête SQL (DQL)

     CF : PostRepository.php
     CF : Query Builder : https://www.doctrine-project.org/projects/doctrine-orm/en/2.6/reference/query-builder.html



--------------------------------------------------
ETAPE 6 : Les formulaires et validation des données
Sommaire :
1/ Le fonctionnement des formulaires sur SF
2/ Générer les formulaire
3/ Récupérer les données des formulaires
4/ personnaliser avec Bootstrap
5/ Update un enregistrement
6/ Validation des données
7/ Champs file
8/ Lien vers doc
-----------------------------------
1/ Le fonctionnement des formulaires sur SF

	De la même manière qu'on ne manipule pas des tables de la BDD, mais des entités (objets), chaque formulaire est lié à une entité.

	Ainsi un formulaire est lié à un objet :

	Inscription ----------> objet User
	Ajout de post -----> objet Post
	Modifier un post --> objet Post

2/ Générer les formulaire

	<cmd>
	php bin/console make:form
	PostType (nom de la classe)
	Post (Entity correspondante)


3/ Récupérer les données des formulaires

	A. Dans le controller il faut le formulaire
	<code>
	use App\Form\PostType;
	$form = $this -> createForm(PostType::class, $post);


	B. On génère la vue du formulaire
	<code>php
	'postForm' => $form -> createView

	<code>twig
	form(postForm) ---> Tout le formulaire

	C. Dans le controller
	<code>
	$form -> handleRequest($request);
	/!\ Cette ligne est importante pour pouvoir récupérer les données en POST.

	if($form -> isSubmitted() && $form -> isValid())


4/ personnaliser avec Bootstrap

	<code>Config/twig.yaml
	twig:
		form_themes:
			- 'bootstrap_4_layout.html.twig'

5/ Update un enregistrement

	Pour update un enregistrement, on procède de la même manière que pour enregistrer une entrée... la différence est que l'objet lié au formulaire n'est pas vide. On dit qu'il hydrate le formulaire.

6/ Validation des données

	- De base les formulaire sont générés de manière un peu basique. Pour gérer nous-même les contraintes (type de données, taille des données) et la sécurité, on doit définir les ASSERT.

		1/ Directement en PHP dans les classes Types :
			- CF src/Form/PostTypes.php

		2/ Dans les entités en annotations :
			- CF src/Entity/Post.php


7/ Champs file

	Pour la gestion des photos il faut deux choses :
		1/ enregistrer le nom de l'image en BDD
		2/ enregistrer la photo elle-même (octets) sur le serveur.

	Cf function uploadFile() dans l'entité Post


Liens :

FORMS : https://symfony.com/doc/current/reference/forms/types.html
Validation des données : https://symfony.com/doc/current/validation.html


----------------------------------
ETAPE 7 : Sécurité et utilisateur
Sommaire
1/ Niveaux de sécurité
2/ Le fichier de sécurité (security.yaml)
3/ Création routes (connexion, deconnexion, connexion_check)
4/ Classe Membre + BDD (username, password, roles, salt)
5/ Layout
----------------------------------
1/ Niveaux de sécurité

	- De base SF, va considérer un visiteur lambda, comme ANONYME
	- Utilisateur : 	ROLE_USER
	- Admin : 			ROLE_ADMIN
	- Super Admin : 	ROLE_SUPER_ADMIN

	SF fonctionne avec pare-feu

	-> On définit les routes que peuvent emprunter les != roles.

		- si un user anonyme --> Homepage  = OK
		- Si un user anonyme --> profil    = Connexion = profil
		- Si ROLE_USER  --> profil = OK
		- Si ROLE_USER --> Admin/produit = 404
		- Si ANON      --> Admin/produit = Connexion  = 404

2/ Le fichier de sécurité (security.yaml)

	<code>app/config/security.yaml

	On définie plusieurs choses :
	- encoders (la manière dont les password seront encodés)
	- provider (quelle ressource va servir d'utilisateur : MembreEntity, le login: username)
	- Hierarchie : La pyramide des droits
	- les routes form_login et logout (voir le point suivant)
	- Access control : qui a le droit à quoi


	/!\ Attention le YAML est très sensible aux indentations et aux espaces.


3/ Creation des routes

	form_login:
		login_path: connexion (page de connexion)

		check_path: connexion_check (Page de checking de login/password, on doit juste la créée, et la mettre dans l'attribut action de notre formulaire de connexion)

		default_target_path: homepage (La page par défaut sur laquelle on est dirigé une fois connecté. Sinon le parefeu prend le dessus)

	logout:
		path: deconnexion (La route de deconnexion. Doit exister mais est vide)
		target: homepage (page de destination, lorsqu'on se déconnecte).


4/ Classe Membre (implements UserInterface)

	- A partir de maintenant la classe Membre doit implements l'interface UserInterface


	--> username (getter/setter)
	--> password (getter/setter)
	--> role (getter/setter)
	--> salt (getter/setter)


	/!\ Attention lors de l'inscription, il faut penser à définir un role_user par défaut (MembreController -> route inscription.

	--> public function eraseCredentials() : fonction obligatoire pour que SF prenne la main.

	--> getRoles est une fonction obligatoire qui retourne le role sous la forme d'un array


5/ Layout

	Dans les vues on fait la distinction entre le niveau d'acces des utilisateur avec :

	{% if is_granted('IS_AUTHENTICATED_FULLY') %}  : tout le monde (sauf anonyme)
	{% if is_granted('ROLE_USER') %}  : tous les users
	{% if is_granted('ROLE_ADMIN') %}  : tous les admin
	{% if not is_granted('IS_AUTHENTICATED_FULLY') %}  : les anonymes

	{{ app.user.username }} : app.user correspond aux infos de l'utilisateur actuellement connecté


===> Le salage c'est l'idée de rendre un MDP quasiment inviolable en ajoutant au MDP soit une chaîne de caractère que seul le développeur connait (petit site, petite structure), ou alors une chaîne aléatoire pour chaque user... Ensuite pour la connexion, on récupère le salage, pour reconstituer le MDP complet.


Liens et Commande

- Make User : On peut créer l'entité membre en ligne de commande avec

	<cmd>
	php bin/console make:user
	-> Création de l'entité User/Membre
	-> implements UserInterface, getRole, setRole, getSalt, setSalt, eraseCredentials
	-> Security.yaml : Encoder, provider


- Pour le faire en dur voici quelques liens sur la doc utiles :

	https://symfony.com/doc/current/security.html
	https://symfony.com/doc/current/security/form_login_setup.html
	https://symfony.com/doc/current/security/user_provider.html
	https://symfony.com/doc/3.3/security/entity_provider.html


- Lorsqu'on utilise des comptes en memory et qu'on souhaite utiliser le cryptage on peut générer le MDP en ligne de commande :

	<cmd>
	php bin/console security:encode-password '123456'


----------------------------------
ETAPE 8 : Association mapping
----------------------------------

- Grâce à l'association Mapping Doctrine nous permet de gérer facilement les relations existantes entre nos objets (tables en BDD)

- Par exemple :
    - L'objet User va contenir une liste d'objets Post (Array Collection)
    - L'objet Post va contenir un objet User
    - L'objet Post va contenir une liste d'objets Comments

- IL existent plusieurs types de relations :
    - OneToMany (Un User a plusieurs Post)
    - ManyToOne (Plusieurs Post reliés au même user)
    - ManyToMany (Un post peut avoir plusieurs catégories et une catégorie plusieurs post)
    - OneToOne (un user a un numéro de tel, et chaque numéro est relié à un user)

- Mise en place :
    <cmd>
    php bin/console make:entity

    On peut alors ajouter une propriété de type "relation"
    Le système nous guide pour la création de cette relation.

    /!\ Attention : il faut néanmoins que les entités existent déjà.
